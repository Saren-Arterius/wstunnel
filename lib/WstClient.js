// Generated by CoffeeScript 1.10.0
(function() {
  var ClientConn, WsStream, createWsClient, etagHeader, log, net, url, wst_client,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  net = require("net");

  WsStream = require("./WsStream");

  url = require('url');

  log = require("lawg");

  ClientConn = require("./httptunnel/ClientConn");

  etagHeader = require("./etagHeader");

  createWsClient = function() {
    return new (require('websocket').client)();
  };

  module.exports = wst_client = (function(superClass) {
    extend(wst_client, superClass);


    /*
    emit Events:
    'tunnel' (WsStream|ClientConn) when a tunnel is established
    'connectFailed' (err) when ws connection failed
    'connectHttpFailed' (err) when http tunnel connection failed
     */

    function wst_client() {
      this.tcpServer = net.createServer();
    }

    wst_client.prototype.verbose = function() {
      this.on('tunnel', (function(_this) {
        return function(ws, sock) {
          if (ws instanceof WsStream) {
            log('Websocket tunnel established');
          } else {
            log('Http tunnel established');
          }
          return sock.on('close', function() {
            return log('Tunnel closed');
          });
        };
      })(this));
      this.on('connectHttpFailed', (function(_this) {
        return function(error) {
          return log('HTTP connect error: ' + error.toString());
        };
      })(this));
      return this.on('connectFailed', (function(_this) {
        return function(error) {
          return log('WS connect error: ' + error.toString());
        };
      })(this));
    };

    wst_client.prototype.setHttpOnly = function(httpOnly) {
      this.httpOnly = httpOnly;
    };

    wst_client.prototype.start = function(localAddr, wsHostUrl1, remoteAddr, optionalHeaders, cb) {
      var localHost, localPort, ref;
      this.wsHostUrl = wsHostUrl1;
      if (typeof optionalHeaders === 'function') {
        cb = optionalHeaders;
        optionalHeaders = {};
      }
      if (typeof localAddr === 'number') {
        localPort = localAddr;
      } else {
        ref = localAddr.split(':'), localHost = ref[0], localPort = ref[1];
        if (/^\d+$/.test(localHost)) {
          localPort = localHost;
          localHost = null;
        }
        localPort = parseInt(localPort);
      }
      if (localHost == null) {
        localHost = '127.0.0.1';
      }
      this.tcpServer.listen(localPort, localHost, cb);
      return this.tcpServer.on("connection", (function(_this) {
        return function(tcpConn) {
          var bind;
          bind = function(s, tcp) {
            require("./bindStream")(s, tcp);
            return _this.emit('tunnel', s, tcp);
          };
          if (_this.httpOnly) {
            return _this._httpConnect(_this.wsHostUrl, remoteAddr, optionalHeaders, function(err, httpConn) {
              if (!err) {
                return bind(httpConn, tcpConn);
              } else {
                return tcpConn.end();
              }
            });
          } else {
            return _this._wsConnect(_this.wsHostUrl, remoteAddr, optionalHeaders, function(error, wsStream) {
              if (!error) {
                return bind(wsStream, tcpConn);
              } else {
                _this.emit('connectFailed', error);
                return _this._httpConnect(_this.wsHostUrl, remoteAddr, optionalHeaders, function(err, httpConn) {
                  if (!err) {
                    return bind(httpConn, tcpConn);
                  } else {
                    return tcpConn.end();
                  }
                });
              }
            });
          }
        };
      })(this));
    };

    wst_client.prototype.startStdio = function(wsHostUrl1, remoteAddr, optionalHeaders, cb) {
      var bind;
      this.wsHostUrl = wsHostUrl1;
      bind = (function(_this) {
        return function(s) {
          process.stdin.pipe(s);
          s.pipe(process.stdout);
          s.on('close', function() {
            return process.exit(0);
          });
          return s.on('finish', function() {
            return process.exit(0);
          });
        };
      })(this);
      if (this.httpOnly) {
        return this._httpConnect(this.wsHostUrl, remoteAddr, optionalHeaders, (function(_this) {
          return function(err, httpConn) {
            if (!err) {
              bind(httpConn);
            }
            return cb(err);
          };
        })(this));
      } else {
        return this._wsConnect(this.wsHostUrl, remoteAddr, optionalHeaders, (function(_this) {
          return function(error, wsStream) {
            if (!error) {
              bind(wsStream);
              return cb();
            } else {
              _this.emit('connectFailed', error);
              return _this._httpConnect(_this.wsHostUrl, remoteAddr, optionalHeaders, function(err, httpConn) {
                if (!err) {
                  bind(httpConn);
                }
                return cb(err);
              });
            }
          };
        })(this));
      }
    };

    wst_client.prototype._httpConnect = function(url, remoteAddr, optionalHeaders, cb) {
      var httpConn, tunurl;
      tunurl = url.replace(/^ws/, 'http');
      if (remoteAddr) {
        tunurl += "?dst=" + remoteAddr;
      }
      httpConn = new ClientConn(tunurl);
      return httpConn.connect(optionalHeaders, (function(_this) {
        return function(err) {
          if (err) {
            _this.emit('connectHttpFailed', err);
            return cb(err);
          } else {
            return cb(null, httpConn);
          }
        };
      })(this));
    };

    wst_client.prototype._wsConnect = function(wsHostUrl, remoteAddr, optionalHeaders, cb) {
      var urlo, wsClient, wsurl;
      if (remoteAddr) {
        wsurl = wsHostUrl + "/?dst=" + remoteAddr;
      } else {
        wsurl = "" + wsHostUrl;
      }
      wsClient = createWsClient();
      urlo = url.parse(wsurl);
      if (urlo.auth) {
        optionalHeaders.Authorization = 'Basic ' + (new Buffer(urlo.auth)).toString('base64');
      }
      wsClient.connect(wsurl, 'tunnel-protocol', void 0, optionalHeaders);
      wsClient.on('connectFailed', (function(_this) {
        return function(error) {
          return cb(error);
        };
      })(this));
      return wsClient.on('connect', (function(_this) {
        return function(wsConn) {
          var wsStream;
          wsStream = new WsStream(wsConn);
          return cb(null, wsStream);
        };
      })(this));
    };

    return wst_client;

  })(require('events').EventEmitter);

}).call(this);

//# sourceMappingURL=WstClient.js.map
