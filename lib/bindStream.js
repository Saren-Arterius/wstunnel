// Generated by CoffeeScript 1.10.0
(function() {
  var _, _n, debug, future, log, name;

  _ = require("underscore");

  log = require("lawg");

  future = require("phuture");

  debug = require("./debug");

  _n = 0;

  name = function(stream) {
    return stream._sig || "tcp";
  };

  module.exports = function(s1, s2) {
    var SpeedMeter, autoPipe, dlog, llog, manualPipe, n, stop;
    n = _n++;
    llog = function(stream, msg) {
      return log(n + " " + (name(stream)) + " " + msg);
    };
    if (debug.isDebug) {
      dlog = llog;
    } else {
      dlog = function() {};
    }
    stop = function() {
      if (!this._stop) {
        dlog(this, 'stop');
        this._stop = true;
        return this.end();
      }
    };
    s1.stop = stop;
    s2.stop = stop;
    s1.on('error', function(err) {
      llog(s1, err);
      s1.stop();
      return s2.stop();
    });
    s2.on('error', function(err) {
      llog(s2, err);
      s2.stop();
      return s1.stop();
    });
    manualPipe = function() {
      s1.on('data', function(data) {
        if (!s2._stop) {
          return s2.write(data);
        }
      });
      s2.on('data', function(data) {
        if (!s1._stop) {
          return s1.write(data);
        }
      });
      s1.on('finish', function() {
        dlog(s1, 'finish');
        return s2.stop();
      });
      s1.on('end', function() {
        dlog(s1, 'end');
        return s2.stop();
      });
      s1.on('close', function() {
        dlog(s1, 'close');
        return s2.stop();
      });
      s2.on('finish', function() {
        dlog(s2, 'finish');
        return s1.stop();
      });
      s2.on('end', function() {
        dlog(s2, 'end');
        return s1.stop();
      });
      return s2.on('close', function() {
        dlog(s2, 'close');
        return s1.stop();
      });
    };
    autoPipe = function() {
      var end;
      s1.on('close', function() {
        dlog(s1, 'close');
        return s2.stop();
      });
      s2.on('close', function() {
        dlog(s2, 'close');
        return s1.stop();
      });
      end = true;
      return s1.pipe(s2, {
        end: end
      }).pipe(s1, {
        end: end
      });
    };
    autoPipe();
    SpeedMeter = (function() {
      function SpeedMeter(msg1) {
        this.msg = msg1;
        this.n = 0;
        this.timer = future.interval(1000, (function(_this) {
          return function() {
            if (_this.n > 0) {
              log(_this.msg + " " + (_this.n / 1000) + "k/s");
              return _this.n = 0;
            }
          };
        })(this));
      }

      SpeedMeter.prototype.attach = function(readStream) {
        readStream.on('data', (function(_this) {
          return function(d) {
            return _this.n += d.length;
          };
        })(this));
        return readStream.on('end', (function(_this) {
          return function() {
            return _this.timer.cancel();
          };
        })(this));
      };

      return SpeedMeter;

    })();
    if (debug.isDebug) {
      (new SpeedMeter(name(s1))).attach(s1);
      return (new SpeedMeter(name(s2))).attach(s2);
    }
  };

}).call(this);

//# sourceMappingURL=bindStream.js.map
